function [xmin,fmin,nFeval,nExp,nIC,nOC,nShrink,iter,BestCost] = IANMS(objfnc, nVar, VarMin, VarMax, maxIter, maxnFeval, tol, u, x, y, varEps)
%
% Adaptive Nelder-Mead Simplex Algorithm with Initial Simplex generated by Halton or Sobol distribution
% for solving the unconstrained optimization problem:
%         min f(x).
%
% It uses the improved version of adaptive parameters introduced in the following paper:
%              Fuchang Gao and Lixing Han
% "Implementing the Nelder-Mead simplex algorithm with adaptive parameters"
%  Computational Optimization and Applications, 2012, 51: 259-277.
% It also uses a population generated by Sobol or Halton Sequence to create the initial simplex
%
%  by Korhan Günel
%  coded January, 2019
%
% Inputs:
%   objfnc   : Objective function
%   nVar     : dimension of problem
%   VarMin   : Lower bound of search space
%   VarMax   : Upper bound of search space
%   maxIter  : Maximum number of iteration
%   maxnFeval : Maximum number of cost function evaluation
%   tol      : Tolerance for stopping criterion
%
% Outputs:
%   xmin     : Approximate optimal solution
%   fmin     : The function value at xmin
%   nFeval   : # of function evaluations
%   nExp     : # of expansion operations
%   nIC      : # of inside contraction operations
%   nOC      : # of outside contraction operations
%   nShrink  : # of shrink operations
%   BestCost : Best cost value obtained for each iteration

%% Settings
L = 50; % Delay time
ns = 25;                        % Sub-mesh size for measured T
nx = floor(size(x,1)/ns)-1;     % Mesh size for measured T
pfunc = 'f';
bfunc = 'g';
measuredT = u;
dim = nVar;
objfnc = fcnchk(objfnc);

% Create initial simplex
X = VarMin + (VarMax - VarMin)*rand(dim+1,nVar);
fX=zeros(1,dim+1);
for i=1:dim+1
     fX(i)=feval(objfnc, X(i,:), pfunc, bfunc, measuredT, x, y, VarMin, VarMax, nx, ns, varEps);
end
nFeval=dim+1;
[fX,I]=sort(fX);
X=X(I,:);

%% Nelder-Mead with Weighted Means 
BestCost = zeros(1,maxIter);
nExp = 0; nIC = 0; nOC =0; nShrink = 0;
calpha = 0; cbeta = 0; cgamma1 = 0; cgamma2 = 0; cdelta = 0; 
for iter = 1:maxIter
    
%     if max(max(abs(X(2:nVar+1,:) - X(1:nVar,:)))) <= tol
%         % Stopping criterion : Check diameter is equal or less than the tolerance value
%        % break;
%     end
%     
%     if nFeval >= maxnFeval
%         %Stopping criterion
%         break;
%     end
    
	 
    % Centroid of the best vertices
    % w = (2*(nVar-(1:nVar))+1)/(nVar^2);
    % M = mean(w.*X(1:nVar,:));
     w = (2*(dim-(1:dim))+1)/(dim^2);
     %w=[w w];
     w=w';
     M = mean(w.*X(1:dim,:));
    
    % Initialize adaptive parameters
    alpha = 1;
    %beta = 2 + cbeta/maxIter; %2 + 1/(1+cbeta);
    gamma1 = 0.75 + 0.1/(1+cgamma1);
    gamma2 = 0.5 - 0.1/(1+cgamma2);
    delta = 0.5 + 0.1/(1+cdelta);
    term = (nVar^2 - w.*(nVar-w))./(w.*(nVar-w));
    if iscolumn(term)
        beta =  term';
    else
        beta = term;
    end
    
    % Reflection point
    R = reflection(alpha,M,X(nVar+1,:));
    fR = feval(objfnc, R, pfunc, bfunc, measuredT, x, y, VarMin, VarMax, nx, ns, varEps);
    nFeval = nFeval + 1;
    if fR < fX(1)
        % Update parameter for expansion point
        E = expansion(beta,M,R);
        fE = feval(objfnc, E, pfunc, bfunc, measuredT, x, y, VarMin, VarMax, nx, ns, varEps);
        nFeval = nFeval + 1;
        nExp = nExp + 1;
        if fE < fR
            X(nVar+1,:) = E;
            fX(nVar+1) = fE;
			cbeta = cbeta + 1;
        else
            X(nVar+1,:) = R;
            fX(nVar+1) = fR;
			calpha= calpha + 1;
        end
    else
        if fR < fX(nVar)
            % accept reflection point
            X(nVar+1,:) = R;
            fX(nVar+1) = fR;
			calpha = calpha + 1;
        else
            if fR < fX(nVar+1)
                % Update parameter for Outside Contraction point
                OC = outsideContraction(gamma1,M,R);
                fOC = feval(objfnc, OC, pfunc, bfunc, measuredT, x, y, VarMin, VarMax, nx, ns, varEps);
                nFeval = nFeval + 1;
                nOC = nOC + 1;
                if fOC <= fR
                    X(nVar+1,:) = OC;
                    fX(nVar+1) = fOC;
					cgamma1 = cgamma1 + 1;
                else
                    % Shrink
                    for i=2:nVar+1
                        % Update parameter for shrink point
                        S = shrink(delta,X(1,:),X(i,:));
                        fS = feval(objfnc, S, pfunc, bfunc, measuredT, x, y, VarMin, VarMax, nx, ns, varEps);
                        nFeval = nFeval + 1;
                        X(i,:) = S;
                        fX(i) = fS;
                    end
                    nShrink = nShrink + nVar;
					cdelta = cdelta+1;
                end
            else
                % Update parameter for Inside Contraction point
                IC = insideContraction(gamma2,M,R);
                fIC = feval(objfnc, IC, pfunc, bfunc, measuredT, x, y, VarMin, VarMax, nx, ns, varEps);
                nFeval = nFeval + 1;
                nIC = nIC + 1;
                if fIC < fX(nVar+1)
                    X(nVar+1,:) = IC;
                    fX(nVar+1) = fIC;
					cgamma2 = cgamma2 + 1;
                else
                    % Shrink
                    for i=2:nVar+1
                        % Update parameter for shrink point
                        S = shrink(delta,X(1,:),X(i,:));
                        fS = feval(objfnc, S, pfunc, bfunc, measuredT, x, y, VarMin, VarMax, nx, ns, varEps);
                        nFeval = nFeval + 1;
                        X(i,:) = S;
                        fX(i) = fS;
                    end
                    nShrink = nShrink + nVar;
					cdelta = cdelta+1;
                end
            end
        end
    end
    [fX,I] = sort(fX);
    X = X(I,:);
    BestCost(iter) = fX(1);
    
    if (iter>L) && (BestCost(iter)== BestCost(iter-L))
        X(dim+1,:) = VarMin + (VarMax - VarMin)*rand(1,nVar);
        fX(dim+1)=feval(objfnc, X(dim+1,:), pfunc, bfunc, measuredT, x, y, VarMin, VarMax, nx, ns, varEps);
    end
    
    [fX,I] = sort(fX);
    X = X(I,:);
    BestCost(iter) = fX(1);
    
    if mod(iter,100)==0
       fprintf('Iteration = %4d\t :\t Best Cost = %5.4e\n', iter, BestCost(iter));
      % fprintf('\t beta : %3.2f\n\t gamma : %3.2f\n\t delta : %3.2f\n',beta,gamma,delta);
    end
    
end
xmin = X(1,:);
fmin = fX(1);