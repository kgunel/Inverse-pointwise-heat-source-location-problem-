% Generated by Korhan Günel, 2017.

tic;
clear; close; clc

exampleNo = 1;
load('data_poisson_epss_0.01_201x201.mat');
%% Problem specification
nx = 199; % number of inner-nodes in 1D
xa = -1; % left boundary point of spatial space
xb = 1;  % right boundary point of spatial space
h = (xb-xa)/(nx+1); % Mesh spacing
varEps = 1e-2;

%% Parameters
Max_Iteration  = 1000;       % Maximum number of "iterations"
maxnFeval = 10^12;             % Maximum number of cost function evalution
nHeatSource = 10;             % Number of Heat Sources
maxnTrials = 25;               % Maximum number of trials
tol = realmin;                % Tolerance as a stopping criteria
low = xa; % Lower bound
up  = xb;  % Upper bound

parameters = [low up Max_Iteration];

empty_Sol.Problem.funName = '';
empty_Sol.Problem.nVar = 10;
empty_Sol.Problem.VarMin = -1;
empty_Sol.Problem.VarMax = 1;
empty_Sol.xmin = [];
empty_Sol.fmin = Inf;
empty_Sol.nFeval = 0;
empty_Sol.nExp = 0;
empty_Sol.nIN = 0;
empty_Sol.nOC = 0;
empty_Sol.nShrink = 0;
empty_Sol.nIter = 0;
empty_Sol.BestCost = [];

%% Main loop
for heatSourceId=1:nHeatSource
    fprintf('\n%2d. heat source position = (%.6f,%.6f)\n', heatSourceId, real_heat_source(heatSourceId).x, real_heat_source(heatSourceId).y);
    disp('  The optimization is starting for the inverse problem...');
    for trialId=1:maxnTrials
        fprintf('\n  Trial Id : %d\n',trialId);
        disp('------------------------------------------------------------------------------------------');
        [xmin,fmin,nFeval,nExp,nIC,nOC,nShrink,iter,BestCost] = NMS('Cost', 2, low, up, Max_Iteration, maxnFeval, tol, sol(heatSourceId).u, sol(heatSourceId).x, sol(heatSourceId).y, varEps);
        
        sol(heatSourceId).Trial(trialId).GlobalBest.Cost = fmin;
        sol(heatSourceId).Trial(trialId).GlobalBest.Position = xmin;
        sol(heatSourceId).Trial(trialId).GlobalBestCostList = BestCost;
        % Her bir ýsý kaynaðý için en iyi çözümü belirle
        if trialId==1
            sol(heatSourceId).Best.GlobalBestCost = sol(heatSourceId).Trial(trialId).GlobalBest.Cost;
            sol(heatSourceId).Best.GlobalBest.Position = sol(heatSourceId).Trial(trialId).GlobalBest.Position;
            sol(heatSourceId).Best.GlobalCostList = sol(heatSourceId).Trial(trialId).GlobalBestCostList;
        else
            if sol(heatSourceId).Best.GlobalBestCost > sol(heatSourceId).Trial(trialId).GlobalBest.Cost
               sol(heatSourceId).Best.GlobalBestCost = sol(heatSourceId).Trial(trialId).GlobalBest.Cost;
               sol(heatSourceId).Best.GlobalBest.Position = sol(heatSourceId).Trial(trialId).GlobalBest.Position;
               sol(heatSourceId).Best.GlobalCostList = sol(heatSourceId).Trial(trialId).GlobalBestCostList;
            end
        end
        fprintf('\n Best Solution for the heat source at (%.6f,%.6f) is\n \t (%f,%f)\n',...
             real_heat_source(heatSourceId).x, real_heat_source(heatSourceId).y,...
             sol(heatSourceId).Best.GlobalBest.Position(1), sol(heatSourceId).Best.GlobalBest.Position(2));

        disp('------------------------------------------------------------------------------------------');
    end
    % Tüm çözümler içinde en iyi çözümü belirle
    if heatSourceId==1
            bestofSolution.Index = 1;
            bestofSolution.GlobalBestCost = sol(heatSourceId).Best.GlobalBestCost;
            bestofSolution.GlobalBest = sol(heatSourceId).Best.GlobalBest;
            bestofSolution.GlobalCostList = sol(heatSourceId).Best.GlobalCostList;
    else
        if bestofSolution.GlobalBestCost > sol(heatSourceId).Best.GlobalBestCost
            bestofSolution.Index = heatSourceId;
            bestofSolution.GlobalBestCost = sol(heatSourceId).Best.GlobalBestCost;
            bestofSolution.GlobalBest.Position = sol(heatSourceId).Best.GlobalBest.Position;
            bestofSolution.GlobalCostList = sol(heatSourceId).Best.GlobalCostList;
        end
    end
end
fprintf('\n Best of best solution is obtained for the heat source at (%.6f,%.6f),\n and it is calculated as (%f,%f) \n',...
    real_heat_source(bestofSolution.Index).x, real_heat_source(bestofSolution.Index).y,... 
    bestofSolution.GlobalBest.Position(1), bestofSolution.GlobalBest.Position(2));

%% Calculate Errors
disp('Absolute  Errors for Heat Source Position...');
absError_x = zeros(1,nHeatSource); % Obtained using global best solutions
absError_y = zeros(1,nHeatSource); % Obtained using global best solutions
MSEs = zeros(1,nHeatSource);       % Obtained for each trials
fprintf('Trial Id\t E_x \t E_y\n');
disp('---------------------------------------------------------------------');
for heatSourceId=1:nHeatSource
    absError_x(heatSourceId) = abs(real_heat_source(heatSourceId).x - sol(heatSourceId).Best.GlobalBest.Position(1));
    absError_y(heatSourceId) = abs(real_heat_source(heatSourceId).y - sol(heatSourceId).Best.GlobalBest.Position(2));
    fprintf('   %2d\t %0.6e\t %0.6e\n',heatSourceId,absError_x(heatSourceId),absError_y(heatSourceId));
    for trialId=1:maxnTrials
      MSEs(heatSourceId) =  MSEs(heatSourceId) + (real_heat_source(heatSourceId).x - sol(heatSourceId).Trial(trialId).GlobalBest.Position(1))^2 + ...
          (real_heat_source(heatSourceId).y - sol(heatSourceId).Trial(trialId).GlobalBest.Position(2))^2;
    end
    MSEs(heatSourceId) = MSEs(heatSourceId)/maxnTrials;
end
disp('---------------------------------------------------------------------');
fprintf('Mean of absolute errors : \n\t for x: %0.6e %c %0.6e \n\t for y: %0.6e %c %0.6e\n\n',...
    mean(absError_x), 177, std(absError_x),  mean(absError_y), 177, std(absError_y));

disp('Mean Squared  Errors for Heat Source Position...');
fprintf('Trial Id\t MSE\n');
disp('---------------------------------------------------------------------');
for heatSourceId=1:nHeatSource
    fprintf('   %2d\t    %0.6e\n',heatSourceId,MSEs(heatSourceId));
end
disp('---------------------------------------------------------------------');
fprintf('Mean of MSEs : %0.6e %c %0.6e \n', mean(MSEs), 177, std(MSEs));   

save('Result\Results_NMS.mat')


%% Plotting
% Plotting Real Heat Source Positions and Calculated One
figure
set(gcf, 'DefaultAxesFontSize', 12),
hold on;
subset =[];
for heatSourceId=1:nHeatSource
    p = plot(real_heat_source(heatSourceId).x, real_heat_source(heatSourceId).y,'o','LineWidth',2,...
        'MarkerSize',10,'MarkerEdgeColor',myColorCodes(15+heatSourceId));
    subset = [subset p];
    plot(sol(heatSourceId).Best.GlobalBest.Position(1),sol(heatSourceId).Best.GlobalBest.Position(2),'kx','LineWidth',1,...
        'MarkerSize',8);
end
axis([-1 1 -1 1]);
xlabel('$x$','Interpreter','Latex' ), ylabel('$y$','Interpreter','Latex'  );
%title('\bf Randomly generated locations of 10 heat sources founded by NMS','Interpreter','Latex');
legend(subset,'\fontsize{10} 1. heat source','\fontsize{10} 2. heat source','\fontsize{10} 3. heat source','\fontsize{10} 4. heat source',...
       '\fontsize{10} 5. heat source','\fontsize{10} 6. heat source','\fontsize{10} 7. heat source',...
       '\fontsize{10} 8. heat source','\fontsize{10} 9. heat source','\fontsize{10} 10. heat source',...
       'Location','northeastoutside');
hold off
fig=gcf;
print(fig,'HeatSources_NMS.eps','-painters','-depsc','-r300');


% Plotting source term function F_eps
figure,
set(gcf, 'DefaultAxesFontSize' ,12),
mesh(sol(bestofSolution.Index).x,sol(bestofSolution.Index).y,...
    -feval('f',real_heat_source(bestofSolution.Index).x, real_heat_source(bestofSolution.Index).y, sol(bestofSolution.Index).x, sol(bestofSolution.Index).y, epss));
xlabel('$x$','Interpreter','Latex' ), ylabel('$y$','Interpreter','Latex'  ), zlabel('$F_\varepsilon(x,y)$','Interpreter','Latex'  ),
title(['\bf{Pointwise heat source} $F_\varepsilon(x,y)$ where $\varepsilon =$ ' num2str(epss)],'Interpreter','Latex');
% Plot solution
fig=gcf;
print(fig,'FigF.eps','-painters','-depsc','-r300');

% Plotting numerical solution
figure,
set(gcf, 'DefaultAxesFontSize' ,12),
meshc(sol(bestofSolution.Index).x,sol(bestofSolution.Index).y,sol(bestofSolution.Index).u);
xlabel('$x$','Interpreter','Latex' ), ylabel('$y$','Interpreter','Latex' ), zlabel('$u(x,y)$','Interpreter','Latex' );
title(strcat('\bf{Numerical Solution to Poisson Equation,} \textit{h} =\, ' ,num2str(h)),'Interpreter','Latex');
fig = gcf; % Get current figure
print(fig,'FigT.eps','-painters','-depsc','-r300');

% Plotting best Cost function found so far
fig = figure;
semilogy(bestofSolution.GlobalCostList(1:100),'-g','LineWidth',1.5,'Color',myColorCodes(22));
title('\fontsize{12}\bf Cost Function');
xlabel('\fontsize{12}\bf Iteration');ylabel('\fontsize{12}\bf Best cost value found so far ');
legend('\fontsize{10}\bf NMS');
fig.InvertHardcopy = 'on';
print(fig,'Figure_Cost.eps','-depsc','-r300');